-- Consolidated 20260106 Migration: Geofence Fixes, RLS, and Logic
-- 1. Table Alterations and Column Fixes
DO $$
BEGIN
    -- worker_boundary_events: add remarks
    IF EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'worker_boundary_events') THEN
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'worker_boundary_events' AND column_name = 'remarks') THEN
            ALTER TABLE public.worker_boundary_events ADD COLUMN remarks TEXT;
        END IF;
        ALTER TABLE public.worker_boundary_events ALTER COLUMN created_at SET DEFAULT NOW();
    END IF;

    -- production_outofbounds: fix worker_id type (TEXT)
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'production_outofbounds' AND column_name = 'worker_id' AND data_type = 'uuid') THEN
        ALTER TABLE public.production_outofbounds RENAME COLUMN worker_id TO worker_id_old;
        ALTER TABLE public.production_outofbounds ADD COLUMN worker_id TEXT;
        UPDATE public.production_outofbounds SET worker_id = worker_id_old::text;
        ALTER TABLE public.production_outofbounds DROP COLUMN worker_id_old;
    END IF;
    ALTER TABLE public.production_outofbounds ALTER COLUMN exit_time SET DEFAULT NOW();
    ALTER TABLE public.production_outofbounds ALTER COLUMN created_at SET DEFAULT NOW();
END $$;

-- 2. New Tables
CREATE TABLE IF NOT EXISTS public.owner_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organization_code TEXT,
    device_name TEXT,
    os_version TEXT,
    login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. RLS Policies (Allow all for anon to support custom login apps)
DO $$
DECLARE
    tbl TEXT;
BEGIN
    FOR tbl IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('production_outofbounds', 'worker_boundary_events', 'daily_geofence_summaries', 'notifications', 'owner_logs')
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY', tbl);
        EXECUTE format('DROP POLICY IF EXISTS "Allow all for anon" ON public.%I', tbl);
        EXECUTE format('CREATE POLICY "Allow all for anon" ON public.%I FOR ALL USING (true) WITH CHECK (true)', tbl);
    END LOOP;
END $$;

-- 4. Foreign Key Relationships
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'production_outofbounds_worker_id_fkey') THEN
        ALTER TABLE public.production_outofbounds ADD CONSTRAINT production_outofbounds_worker_id_fkey FOREIGN KEY (worker_id) REFERENCES public.workers(worker_id) ON DELETE CASCADE;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'worker_boundary_events_worker_id_fkey') THEN
        ALTER TABLE public.worker_boundary_events ADD CONSTRAINT worker_boundary_events_worker_id_fkey FOREIGN KEY (worker_id) REFERENCES public.workers(worker_id) ON DELETE CASCADE;
    END IF;
END $$;

-- 5. Duration Calculation Logic
CREATE OR REPLACE FUNCTION calculate_duration_minutes(start_t timestamptz, end_t timestamptz)
RETURNS TEXT AS $$
DECLARE
    diff interval;
    total_minutes integer;
BEGIN
    IF start_t IS NULL OR end_t IS NULL THEN RETURN NULL; END IF;
    diff := end_t - start_t;
    total_minutes := EXTRACT(EPOCH FROM diff) / 60;
    RETURN total_minutes || ' mins';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION trg_calculate_oob_duration()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.entry_time IS NOT NULL AND OLD.entry_time IS NULL THEN
        NEW.duration_minutes := calculate_duration_minutes(NEW.exit_time, NEW.entry_time);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS calculate_oob_duration_trg ON public.production_outofbounds;
CREATE TRIGGER calculate_oob_duration_trg BEFORE UPDATE ON public.production_outofbounds FOR EACH ROW EXECUTE FUNCTION trg_calculate_oob_duration();

-- 6. Robust Geofence Summary Trigger & Backfill
CREATE OR REPLACE FUNCTION public.update_geofence_summary()
RETURNS TRIGGER AS $$
DECLARE
    event_date DATE;
BEGIN
    IF NEW.type NOT IN ('entry', 'exit') THEN RETURN NEW; END IF;
    event_date := (NEW.created_at AT TIME ZONE 'UTC')::DATE;
    INSERT INTO public.daily_geofence_summaries (worker_id, organization_code, date, first_entry_time, entry_count, exit_count, last_event_time)
    VALUES (NEW.worker_id, NEW.organization_code, event_date, CASE WHEN NEW.type = 'entry' THEN NEW.created_at ELSE NULL END, CASE WHEN NEW.type = 'entry' THEN 1 ELSE 0 END, CASE WHEN NEW.type = 'exit' THEN 1 ELSE 0 END, NEW.created_at)
    ON CONFLICT (worker_id, date, organization_code) DO UPDATE SET
        first_entry_time = CASE 
            WHEN daily_geofence_summaries.first_entry_time IS NULL AND EXCLUDED.first_entry_time IS NOT NULL THEN EXCLUDED.first_entry_time
            WHEN daily_geofence_summaries.first_entry_time IS NOT NULL AND EXCLUDED.first_entry_time IS NOT NULL AND EXCLUDED.first_entry_time < daily_geofence_summaries.first_entry_time THEN EXCLUDED.first_entry_time
            ELSE daily_geofence_summaries.first_entry_time
        END,
        entry_count = daily_geofence_summaries.entry_count + (CASE WHEN NEW.type = 'entry' THEN 1 ELSE 0 END),
        exit_count = daily_geofence_summaries.exit_count + (CASE WHEN NEW.type = 'exit' THEN 1 ELSE 0 END),
        last_event_time = GREATEST(daily_geofence_summaries.last_event_time, NEW.created_at);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Backfill existing data
TRUNCATE TABLE public.daily_geofence_summaries;
INSERT INTO public.daily_geofence_summaries (worker_id, organization_code, date, first_entry_time, entry_count, exit_count, last_event_time)
SELECT worker_id, organization_code, (created_at AT TIME ZONE 'UTC')::DATE, MIN(CASE WHEN type = 'entry' THEN created_at ELSE NULL END), COUNT(CASE WHEN type = 'entry' THEN 1 ELSE NULL END), COUNT(CASE WHEN type = 'exit' THEN 1 ELSE NULL END), MAX(created_at)
FROM public.worker_boundary_events WHERE type IN ('entry', 'exit')
GROUP BY worker_id, organization_code, (created_at AT TIME ZONE 'UTC')::DATE
ON CONFLICT (worker_id, date, organization_code) DO NOTHING;

-- 7. Helper Functions for App
CREATE OR REPLACE FUNCTION handle_worker_return(event_id uuid, entry_lat double precision, entry_lng double precision)
RETURNS void AS $$
BEGIN
    UPDATE public.production_outofbounds SET entry_time = NOW(), entry_latitude = entry_lat, entry_longitude = entry_lng WHERE id = event_id;
END;
$$ LANGUAGE plpgsql;

-- 8. Standardize Timestamps & Indexes
ALTER TABLE public.production_logs ADD COLUMN IF NOT EXISTS timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW();
ALTER TABLE public.production_logs ALTER COLUMN timestamp SET DEFAULT NOW(), ALTER COLUMN created_at SET DEFAULT NOW();
ALTER TABLE public.attendance ALTER COLUMN check_in SET DEFAULT NOW(), ALTER COLUMN created_at SET DEFAULT NOW();

CREATE INDEX IF NOT EXISTS idx_owner_logs_login_time ON public.owner_logs(login_time DESC);
CREATE INDEX IF NOT EXISTS idx_production_logs_timestamp ON public.production_logs(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_check_in ON public.attendance(check_in DESC);
CREATE INDEX IF NOT EXISTS idx_outofbounds_exit_time ON public.production_outofbounds(exit_time DESC);
